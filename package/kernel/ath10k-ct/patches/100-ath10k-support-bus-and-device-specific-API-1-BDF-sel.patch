From fe83e88124afb803c4ac66680be75b95519bc32a Mon Sep 17 00:00:00 2001
From: Robert Marko <robimarko@gmail.com>
Date: Sat, 9 Oct 2021 20:24:27 +0200
Subject: [PATCH] ath10k: support bus and device specific API 1 BDF selection

Some ath10k IPQ40xx devices like the MikroTik hAP ac2 and ac3 require the
BDF-s to be extracted from the device storage instead of shipping packaged
API 2 BDF-s.

This is required as MikroTik has started shipping boards that require BDF-s
to be updated, as otherwise their WLAN performance really suffers.
This is however impossible as the devices that require this are release under
the same revision and its not possible to differentiate them from devices
using the older BDF-s.

In OpenWrt we are extracting the calibration data during runtime and we are
able to extract the BDF-s in the same manner, however we cannot package the
BDF-s to API 2 format on the fly and can only use API 1 to provide BDF-s on
the fly.
This is an issue as the ath10k driver explicitly looks only for the board.bin
file and not for something like board-bus-device.bin like it does for pre-cal
data.
Due to this we have no way of providing correct BDF-s on the fly, so lets
extend the ath10k driver to first look for BDF-s in the board-bus-device.bin
format, for example: board-ahb-a800000.wifi.bin
If that fails, look for the default board file name as defined previously.

Signed-off-by: Robert Marko <robimarko@gmail.com>
---
 ath10k-5.15/core.c | 29 ++++++++++++++++++++---------
 1 file changed, 20 insertions(+), 9 deletions(-)

--- a/ath10k-5.15/core.c
+++ b/ath10k-5.15/core.c
@@ -1503,6 +1503,7 @@ done:
 static int ath10k_core_fetch_board_data_api_1(struct ath10k *ar, int bd_ie_type)
 {
 	const struct firmware *fw;
+	char device_boardname[100], boardname[100];
 
 	if (bd_ie_type == ATH10K_BD_IE_BOARD) {
 		if (!ar->hw_params.fw.board) {
@@ -1510,14 +1511,27 @@ static int ath10k_core_fetch_board_data_
 			return -EINVAL;
 		}
 
-		if (ar->fwcfg.bname[0])
+		scnprintf(device_boardname, sizeof(device_boardname), "board-%s-%s.bin",
+			  ath10k_bus_str(ar->hif.bus), dev_name(ar->dev));
+
+		if (ar->fwcfg.bname[0]) {
 			ar->normal_mode_fw.board = ath10k_fetch_fw_file(ar,
 									ar->hw_params.fw.dir,
 									ar->fwcfg.bname);
-		else
+			strlcpy(boardname, ar->fwcfg.bname, sizeof(boardname));
+		}
+		else {
 			ar->normal_mode_fw.board = ath10k_fetch_fw_file(ar,
 									ar->hw_params.fw.dir,
-									ar->hw_params.fw.board);
+									device_boardname);
+			if (IS_ERR(ar->normal_mode_fw.board)) {
+				ar->normal_mode_fw.board = ath10k_fetch_fw_file(ar,
+										ar->hw_params.fw.dir,
+										ar->hw_params.fw.board);
+				strlcpy(boardname, ar->hw_params.fw.board, sizeof(boardname));
+			} else
+				strlcpy(boardname, device_boardname, sizeof(boardname));
+		}
 		if (IS_ERR(ar->normal_mode_fw.board))
 			return PTR_ERR(ar->normal_mode_fw.board);
 
@@ -1544,12 +1558,7 @@ static int ath10k_core_fetch_board_data_
 	}
 
 	/* Save firmware board name so we can display it later. */
-	if (ar->fwcfg.bname[0])
-		strlcpy(ar->normal_mode_fw.fw_file.fw_board_name, ar->fwcfg.bname,
-			sizeof(ar->normal_mode_fw.fw_file.fw_board_name));
-	else
-		strlcpy(ar->normal_mode_fw.fw_file.fw_board_name, ar->hw_params.fw.board,
-			sizeof(ar->normal_mode_fw.fw_file.fw_board_name));
+	strlcpy(ar->normal_mode_fw.fw_file.fw_board_name, boardname, sizeof(boardname));
 
 	return 0;
 }
